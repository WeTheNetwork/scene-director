{"ast":null,"code":"// ScreenDirector Reference\nimport { Screenplay as _Screenplay, SceneAsset3D } from '../bin/ScreenDirector.js'; // Support Library Reference\n\nimport GUI from 'lil-gui';\nimport * as THREE from 'three';\nimport { GLTFLoader } from '../lib/GLTFLoader.js';\nimport { OrbitControls } from '../lib/OrbitControls.js';\nimport { FirstPersonControls } from '../lib/FirstPersonControls.js'; // Constant Definitions\n\nconst LIGHT = {\n  night: 0x050505,\n  evening: 0x526079,\n  theater: 0x555555,\n  indoor: 0x999999,\n  day: 0xffffff,\n  off: 0x000000,\n  green: 0x00ff00,\n  red: 0xff0000,\n  blue: 0x0000ff\n};\nconst VIEW = {\n  fov: 45,\n  aspect: window.innerWidth / window.innerHeight,\n  near: 0.1,\n  far: 1000\n}; // Screenplay Implementation\n\nclass Screenplay extends _Screenplay {\n  constructor() {\n    super(); // Camera & Controls Setup\n\n    this.actors = {\n      // Lazy Getters\n\n      /*\r\n          The Screenplay contains ALL of the models which your site will EVER need to render.\r\n          Most applications will want to introduce models as needed, in order to optimize system resources.\r\n            asyncronous loaders are used to ensure that the system is not hung up on resource loading.\r\n          - ex: actors.jumping_cube()\r\n            syncronous loaders are used for loading any other assets.\r\n          - ex: lights.point_light()\r\n            Note: Delete the models initialization logic, replacing it with the initialized model object ( see any ).\r\n                This prevents the model from initializing multiple times.\r\n      */\n      // Jumping Cube\n      get jumping_cube() {\n        let loading = new Promise((resolve, reject) => {\n          const loader = new GLTFLoader().setPath('models/');\n          loader.load('jumping_cube.glb', async gltf => {\n            let _jumping_cube = gltf.scene.children[0];\n            _jumping_cube.material = new THREE.MeshStandardMaterial({\n              color: LIGHT.green\n            });\n            _jumping_cube.animations = gltf.animations;\n            _jumping_cube.name = \"Jumping Cube\";\n            let jumping_cube = new SceneAsset3D(_jumping_cube);\n            jumping_cube.directions.set('revolve', function () {\n              jumping_cube.rotation.y += .01;\n            });\n            jumping_cube.mixer = new THREE.AnimationMixer(jumping_cube);\n            var keyAnimationClip = THREE.AnimationClip.findByName(jumping_cube.animations, 'CubeAction.Jump');\n            var action = jumping_cube.mixer.clipAction(keyAnimationClip);\n            action.play();\n            resolve(jumping_cube);\n          }, async function (xhr) {// TODO: Repair progress functionality\n            //console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );\n          }, async err => {\n            console.error(err);\n            reject(err);\n          });\n        });\n        return (async () => {\n          try {\n            return await loading.then(_jumping_cube => {\n              delete this.jumping_cube;\n              return this.jumping_cube = _jumping_cube;\n            });\n          } catch (e) {\n            return 0; // fallback value;\n          }\n        })();\n      }\n\n    };\n    this.lights = {\n      get point_light() {\n        delete this.point_light;\n        return this.point_light = new THREE.PointLight(0xffffff, 2.5, 0, 2);\n      },\n\n      get ambient_light() {\n        delete this.ambient_light;\n        return this.ambient_light = new THREE.AmbientLight(LIGHT.evening);\n      }\n\n    };\n    this.actions = {\n      change_cam: async cam_name => {\n        let _ship = this.actors.Ship;\n\n        let _cam = _ship.cameras.get(cam_name);\n\n        let _cam_pos = new THREE.Vector3();\n\n        _cam.getWorldPosition(_cam_pos);\n\n        this.active_cam.position.copy(_cam_pos);\n\n        let _target_pos = new THREE.Vector3();\n\n        switch (cam_name) {\n          case 'ConnCam':\n            _ship.conn_station.getWorldPosition(_target_pos);\n\n            break;\n\n          case 'OpsCam':\n            _ship.ops_station.getWorldPosition(_target_pos);\n\n            break;\n\n          case 'CaptainCam':\n            _ship.NavDots.sight_target.getWorldPosition(_target_pos);\n\n            break;\n        }\n\n        this.active_cam.lookAt(_target_pos);\n        this.active_cam.updateProjectionMatrix();\n        this.active_cam.name = cam_name;\n      }\n    };\n    this.active_cam = this.cameras.camera_a = new THREE.PerspectiveCamera(VIEW.fov, VIEW.aspect, VIEW.near, VIEW.far);\n    this.cameras.camera_a.name = 'ActiveCam';\n  }\n\n}\n\nexport { Screenplay };","map":{"version":3,"names":["Screenplay","_Screenplay","SceneAsset3D","GUI","THREE","GLTFLoader","OrbitControls","FirstPersonControls","LIGHT","night","evening","theater","indoor","day","off","green","red","blue","VIEW","fov","aspect","window","innerWidth","innerHeight","near","far","constructor","actors","jumping_cube","loading","Promise","resolve","reject","loader","setPath","load","gltf","_jumping_cube","scene","children","material","MeshStandardMaterial","color","animations","name","directions","set","rotation","y","mixer","AnimationMixer","keyAnimationClip","AnimationClip","findByName","action","clipAction","play","xhr","err","console","error","then","e","lights","point_light","PointLight","ambient_light","AmbientLight","actions","change_cam","cam_name","_ship","Ship","_cam","cameras","get","_cam_pos","Vector3","getWorldPosition","active_cam","position","copy","_target_pos","conn_station","ops_station","NavDots","sight_target","lookAt","updateProjectionMatrix","camera_a","PerspectiveCamera"],"sources":["C:/Phox.Solutions/Workshop/GitHub-Repos/WeTheNetwork/scene-director/src/implementation/Screenplay.js"],"sourcesContent":["// ScreenDirector Reference\r\nimport { Screenplay as _Screenplay, SceneAsset3D } from '../bin/ScreenDirector.js';\r\n// Support Library Reference\r\nimport GUI from 'lil-gui';\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from '../lib/GLTFLoader.js';\r\nimport { OrbitControls } from '../lib/OrbitControls.js';\r\nimport { FirstPersonControls } from '../lib/FirstPersonControls.js';\r\n\r\n// Constant Definitions\r\nconst LIGHT = {\r\n  night: 0x050505,\r\n  evening: 0x526079,\r\n  theater: 0x555555,\r\n  indoor: 0x999999,\r\n  day: 0xffffff,\r\n  off: 0x000000,\r\n  green: 0x00ff00,\r\n  red: 0xff0000,\r\n  blue: 0x0000ff\r\n};\r\nconst VIEW = {\r\n  fov: 45,\r\n  aspect: window.innerWidth / window.innerHeight,\r\n  near: 0.1,\r\n  far: 1000\r\n};\r\n\r\n// Screenplay Implementation\r\nclass Screenplay extends _Screenplay{\r\n  actors = {\r\n\r\n    // Lazy Getters\r\n    /*\r\n        The Screenplay contains ALL of the models which your site will EVER need to render.\r\n        Most applications will want to introduce models as needed, in order to optimize system resources.\r\n\r\n        asyncronous loaders are used to ensure that the system is not hung up on resource loading.\r\n        - ex: actors.jumping_cube()\r\n\r\n        syncronous loaders are used for loading any other assets.\r\n        - ex: lights.point_light()\r\n\r\n        Note: Delete the models initialization logic, replacing it with the initialized model object ( see any ).\r\n              This prevents the model from initializing multiple times.\r\n    */\r\n\r\n    // Jumping Cube\r\n    get jumping_cube(){\r\n      let loading = new Promise((resolve, reject)=>{\r\n        const loader = new GLTFLoader().setPath( 'models/' );\r\n        loader.load( 'jumping_cube.glb',\r\n          async ( gltf )=>{\r\n            let _jumping_cube = gltf.scene.children[0];\r\n            _jumping_cube.material = new THREE.MeshStandardMaterial( { color: LIGHT.green } );\r\n            _jumping_cube.animations = gltf.animations;\r\n            _jumping_cube.name = \"Jumping Cube\";\r\n            let jumping_cube = new SceneAsset3D( _jumping_cube );\r\n            jumping_cube.directions.set( 'revolve', function(){\r\n              jumping_cube.rotation.y += .01;\r\n            });\r\n            jumping_cube.mixer = new THREE.AnimationMixer( jumping_cube );\r\n            var keyAnimationClip = THREE.AnimationClip.findByName( jumping_cube.animations, 'CubeAction.Jump' );\r\n            var action = jumping_cube.mixer.clipAction( keyAnimationClip );\r\n            action.play();\r\n            resolve( jumping_cube );\r\n          },\r\n          async function ( xhr ) {\r\n            // TODO: Repair progress functionality\r\n            //console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );\r\n          },\r\n          async ( err )=>{\r\n            console.error( err );\r\n            reject( err );\r\n          }\r\n        );\r\n      });\r\n\r\n\r\n      return (async () => {\r\n      try {\r\n        return await loading.then(( _jumping_cube )=>{\r\n          delete this.jumping_cube;\r\n          return this.jumping_cube = _jumping_cube;\r\n        })\r\n      } catch(e) {\r\n        return 0; // fallback value;\r\n      }\r\n    })();\r\n    }\r\n  }\r\n  lights = {\r\n    get point_light(){\r\n      delete this.point_light;\r\n      return this.point_light = new THREE.PointLight( 0xffffff, 2.5, 0, 2 );\r\n    },\r\n    get ambient_light(){\r\n      delete this.ambient_light;\r\n      return this.ambient_light = new THREE.AmbientLight( LIGHT.evening ) ;\r\n    }\r\n  };\r\n  cameras;\r\n  actions = {\r\n    change_cam: async ( cam_name ) =>{\r\n      let _ship = this.actors.Ship;\r\n      let _cam = _ship.cameras.get( cam_name );\r\n      let _cam_pos = new THREE.Vector3();\r\n      _cam.getWorldPosition( _cam_pos );\r\n      this.active_cam.position.copy( _cam_pos );\r\n      let _target_pos = new THREE.Vector3();\r\n      switch( cam_name ){\r\n        case 'ConnCam':\r\n          _ship.conn_station.getWorldPosition( _target_pos );\r\n          break;\r\n        case 'OpsCam':\r\n          _ship.ops_station.getWorldPosition( _target_pos );\r\n          break;\r\n        case 'CaptainCam':\r\n          _ship.NavDots.sight_target.getWorldPosition( _target_pos );\r\n          break;\r\n      }\r\n      this.active_cam.lookAt( _target_pos );\r\n      this.active_cam.updateProjectionMatrix();\r\n      this.active_cam.name = cam_name;\r\n    }\r\n  };\r\n\r\n\r\n  constructor( ){\r\n    super( );\r\n\r\n    // Camera & Controls Setup\r\n    this.active_cam = this.cameras.camera_a = new THREE.PerspectiveCamera( VIEW.fov, VIEW.aspect, VIEW.near, VIEW.far );\r\n    this.cameras.camera_a.name = 'ActiveCam';\r\n  }\r\n}\r\n\r\nexport { Screenplay }\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}